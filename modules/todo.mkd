TODO:

zbunjuje me jedna stvar:
kad dohvatimo IR, uros se ponasa kao da vec imamo X_direct ako vazi di != indirect_Addressing
    - to bi znacilo da je direktno: da ne odemo u memoriju uopste, nego da uzmemo ona tri bita iz IR

- ali da li to ima smisla? pa, ne. zato sto se za y i z ne ponasamo tako, vec uvek odemo u memoriju da dohvatimo,
a onda tek proveravamo da li je indirektno ili ne.
===========

EXECUTE phase:

add, sub, mul: 
    1. odradi operaciju (bice na izlazu ALU)
    2. stavi izlaz ALU u MDR, a u MAR stavi x_ind
    3. mora da prodje takt da se upie u memoriju, stavi WE = 1

mov:
    1. ako z = 000, u MAR stavi ind_x, u MDR stavi Y
    2. takt upisa u mem, we = 1

in: ???
    1. odakle dovlacimo ovaj podatak?? whatttt

out: ???
    1. dovukli smo u ind_x operand, samo ga saljemo na 7seg displej!

stop:
    1. ako imamo x, ispisi (dovukli smo ga vec)
    2. ako imamo y, ispisi (dovukli)
    3. ako imamo z, ispisi (dovukli)



---
[] add resetting all values to 0 in combinatory logic block
[t] rename INDIRECT_READ to INDIRECT_ADDRESS
[] remove ir2 and ir1(if exists)
[] should localparam[5:0] have width?
[] assign values to all localparams when you figure out their exact count.
[] why do we have we_reg_next ??????????
[] error localparam state? do i need this?

[] decided to go with DECODE. fetch => DECODE => EXEC.
[] figure out what is DECODE_STATE_MAR_IN_X , and why do x,y,z all have their stages for indirect
[] figre out the logic where and how we determine what is indirect and what is not.

[t] map out reading instruction in diagram

[] implement states for reading instruction :)



MAR + MDR LOGIC:
- To read, the CPU places an address in the MAR and activates a read signal; the memory returns data to the MDR. 

- To write, the CPU places the address in the MAR and data in the MDR, then activates a write signal. 


IR, internal cpu registers logic:
- it doesnt make sense to use wires to internally store from IR because IR will change if we read the second instruction.
therefore the wires can be removed, and we can use internal registers instead.
[]? when to clear the registers? => when fetching the new instruction.
[]? should we be re-setting values at the beginning of combinatory logic? => no, because we dont always assign it a value. 


OC, logic with op codes:
- we must store op codes somewhere.
[]? should their value be equal to state? => no, because they might use multiple clock cycles to complete, and the nubmers are next to each other.
[]? how to store the opcodes then? => as localparam values, 4 bits long (thats how it is in the project specification)


DECODE, the logic:

having a DECODE pros:
- one place for all params, before EXEC
- separation of concerns

having a DECODE cons:
- have to chase random ass registers (Where do i put these in??)

===
not having a DECODE pros:
- not chase random ass registers

not having a DECODE cons:
- possibly have extra states...
- ??? how do i pull it off?


* are there cases where we dont have decode?


[]? where do i store the output of mem_ind1, mem_ind2, mem_ind3 ?
[]? where do i store addr1/addr2/addr3 after i read from them?


if mem_indir =>
    - put addr from IR into MAR, then read from mem into MDR
    - then from MDR immediately put the result into MAR again, and read from memory again, put into MDR
    - then from MDR read and put SOMEWHERE (IR? A? idk)

=============================
VERIFICATION MY PROJECT WORKS:


[] All states have proper transitions.
[] All opcodes are matched properly.
[] make sure you properly handle X in INDIRECT checks (Because it might be wrong!)

